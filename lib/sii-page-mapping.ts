/**
 * SII Section to PDF Page Mapping
 * Maps section references (e.g., "5.1") to specific page numbers in SII PDFs
 *
 * This mapping is built manually or can be auto-generated by analyzing PDF structure.
 * For now, we use a best-guess based on typical SII document structure.
 */

export interface SectionPageMapping {
  [section: string]: number;
}

/**
 * Page mappings for each SII document
 * Key: document number (1-15)
 * Value: mapping of section strings to page numbers
 */
export const SII_PAGE_MAPPINGS: Record<number, SectionPageMapping> = {
  // Doc 1: Prepare for service
  1: {
    "5": 6,
    "6": 10,
    "7": 15,
  },

  // Doc 2: Functional safety test
  2: {
    "5": 6,
    "6": 10,
    "7": 11,
    "7.2": 12,
    "7.2.2": 12,
    "7.2.3": 13,
  },

  // Doc 3: Safety equipment
  3: {
    "3": 6,
    "3.5": 8,
    "3.5.1": 8,
    "3.5.5": 10,
    "5": 12,
    "6": 15,
  },

  // Doc 11: Service crane (yearly)
  11: {
    "5": 6,      // Section 5 starts on page 6
    "5.1": 6,    // Section 5.1 - To examine the service crane
    "5.1.1": 6,  // Section 5.1.1 - To do a check of the electric chain hoist
  },

  // Doc 6: Gearbox and gear oil system
  6: {
    "5": 6,
    "5.2": 7,
    "5.2.1": 8,
    "5.2.2": 9,
    "5.2.3": 10,
    "5.2.4": 11,
    "5.2.8": 15,
    "5.2.9": 16,
    "5.2.10": 17,
    "5.2.11": 18,
    "5.2.12": 19,
    "5.2.13": 20,
    "5.3": 21,
    "6.2.6": 25,
    "6.2.7": 26,
  },

  // Doc 9: Nacelle
  9: {
    "5": 6,
    "5.1": 7,
    "5.1.4": 10,
    "5.2": 15,
    "5.2.1": 16,
    "5.2.3": 18,
    "5.4": 20,
    "5.5": 21,
    "5.5.1": 22,
  },

  // Doc 5: Hydraulic systems
  5: {
    "5": 6,
    "5.1": 7,
    "5.1.1": 8,
    "5.1.2": 9,
    "5.1.3": 10,
    "5.1.4": 11,
    "5.1.5": 12,
    "5.1.6": 13,
    "5.2": 14,
    "5.3": 15,
  },

  // Doc 4: Hub and blades
  4: {
    "5": 6,
    "5.1": 7,
    "5.1.1": 8,
    "5.1.2": 10,
    "5.1.3": 12,
    "5.1.5": 14,
    "5.1.6": 15,
    "5.1.7": 16,
    "5.1.8": 17,
    "5.2": 18,
    "5.2.1": 19,
    "5.2.2": 20,
    "5.2.5": 23,
    "5.2.7": 25,
  },

  // Doc 7: Generator
  7: {
    "5": 6,
    "6": 12,
    "6.5": 13,
    "6.5.2": 14,
    "6.5.2.2": 14,
    "6.5.2.3": 15,
    "6.5.2.4": 16,
    "6.5.2.8": 17,
    "6.5.2.9": 18,
    "6.5.2.11": 19,
    "6.5.2.12": 20,
    "6.5.2.13": 21,
    "6.5.3": 22,
    "6.6": 23,
    "6.6.2": 24,
    "6.6.2.6": 24,
    "6.6.2.7": 25,
    "7": 26,
    "9": 30,
    "9.5": 31,
    "9.5.3": 32,
    "9.5.3.1": 32,
  },

  // Doc 8: Cooling and conditioning
  8: {
    "5": 6,
    "6": 12,
    "7": 18,
  },

  // Doc 10: Yaw system
  10: {
    "5": 6,
    "5.2": 10,
    "5.2.5": 10,  // Spring packs section (approximate, adjust based on actual PDF)
    "6": 15,
    "7": 20,
  },

  // Doc 12: High voltage
  12: {
    "5": 6,
    "6": 12,
    "7": 18,
  },

  // Doc 13: Service lift and climb assistance
  13: {
    "5": 6,
    "6": 12,
    "7": 18,
  },

  // Doc 14: Tower
  14: {
    "5": 6,
    "6": 12,
    "7": 18,
  },

  // Doc 15: Finish work
  15: {
    "5": 6,
    "6": 10,
    "7": 15,
  },
};

/**
 * Gets the page number for a specific section in a document
 * Uses smart nearest-neighbor algorithm to find best match
 *
 * Algorithm:
 * 1. Try exact match
 * 2. Try parent sections going backwards (5.2.4.5 -> 5.2.4 -> 5.2 -> 5)
 * 3. Try finding nearest sibling/child by numeric proximity
 *
 * @param documentNumber - The SII document number (1-15)
 * @param section - The section reference (e.g., "5.1", "5.2.3") or empty string for document title
 * @returns Page number to jump to
 */
export function getSectionPage(documentNumber: number, section: string): number {
  const mapping = SII_PAGE_MAPPINGS[documentNumber];
  if (!mapping) {
    console.log(`⚠️ No mapping found for document ${documentNumber}`);
    return 1; // Default to first page if no mapping
  }

  // If no section (e.g., "7. Generator"), return first page
  if (!section || section.trim() === "") {
    return 1;
  }

  // Clean section by removing special suffixes like "i2" from "5.2.7i2"
  const cleanedSection = section.replace(/[a-z]\d+$/, '');

  // STEP 1: Try exact match first (both original and cleaned)
  if (mapping[section]) {
    console.log(`✅ Exact match: "${section}" -> page ${mapping[section]}`);
    return mapping[section];
  }
  if (cleanedSection !== section && mapping[cleanedSection]) {
    console.log(`✅ Cleaned match: "${cleanedSection}" -> page ${mapping[cleanedSection]}`);
    return mapping[cleanedSection];
  }

  // STEP 2: Try parent sections going backwards (e.g., "5.2.4.5" -> "5.2.4" -> "5.2" -> "5")
  const parts = cleanedSection.split('.');
  for (let i = parts.length - 1; i > 0; i--) {
    const parentSection = parts.slice(0, i).join('.');
    if (mapping[parentSection]) {
      console.log(`✅ Parent match: "${cleanedSection}" -> "${parentSection}" -> page ${mapping[parentSection]}`);
      return mapping[parentSection];
    }
  }

  // STEP 3: Smart nearest-neighbor search
  // Find sections with matching prefix and closest numeric value
  const availableSections = Object.keys(mapping);

  // Try each level from most specific to least specific
  for (let prefixLen = parts.length; prefixLen > 0; prefixLen--) {
    const prefix = parts.slice(0, prefixLen).join('.');

    // Find all sections that start with this prefix
    const candidates = availableSections
      .filter(s => s.startsWith(prefix + '.') || s === prefix)
      .map(s => {
        const sParts = s.split('.').map(Number);
        const targetParts = parts.map(Number);

        // Calculate numeric distance (sum of differences at each level)
        let distance = 0;
        for (let i = 0; i < Math.max(sParts.length, targetParts.length); i++) {
          const a = sParts[i] || 0;
          const b = targetParts[i] || 0;
          distance += Math.abs(a - b);
        }

        return { section: s, distance, page: mapping[s] };
      })
      .sort((a, b) => a.distance - b.distance); // Sort by distance

    if (candidates.length > 0) {
      const nearest = candidates[0];
      console.log(`✅ Nearest neighbor: "${cleanedSection}" -> "${nearest.section}" (distance: ${nearest.distance}) -> page ${nearest.page}`);
      return nearest.page;
    }
  }

  // STEP 4: Last resort - find the section with closest first number
  const firstNum = parseInt(parts[0]);
  if (!isNaN(firstNum)) {
    const closestSection = availableSections
      .map(s => ({
        section: s,
        firstNum: parseInt(s.split('.')[0]),
        page: mapping[s]
      }))
      .filter(item => !isNaN(item.firstNum))
      .sort((a, b) => Math.abs(a.firstNum - firstNum) - Math.abs(b.firstNum - firstNum))[0];

    if (closestSection) {
      console.log(`✅ Closest section by first number: "${cleanedSection}" -> "${closestSection.section}" -> page ${closestSection.page}`);
      return closestSection.page;
    }
  }

  console.log(`⚠️ No match found for "${section}" in doc ${documentNumber}, defaulting to page 6`);
  // Default to first content page (usually page 6 after covers/TOC)
  return 6;
}

/**
 * Checks if a mapping exists for a document
 */
export function hasSectionMapping(documentNumber: number): boolean {
  return documentNumber in SII_PAGE_MAPPINGS;
}
